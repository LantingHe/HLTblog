{"pages":[{"title":"关于","date":"2018-04-03T14:19:07.000Z","updated":"2018-04-03T14:19:07.000Z","comments":false,"path":"about/index.html","permalink":"http://charlycheng.xyz/about/index.html","excerpt":"","text":"1234567891011121314151617181920212223242526272829&#123; name: &apos;李长城&apos; age: 27, gender: &apos;男&apos;, profession: &apos;前端开发&apos;, experience: &apos;3年&apos;, address: &apos;北京海淀&apos;, education: &apos;本科&apos;, github: &apos;https://github.com/CharlyCheng&apos;, blog: &apos;http://charlycheng.xyz&apos;, email: &apos;li4900206@163.com&apos;, description: &apos;前端开发，喜爱Node，乐于全栈&apos;, skills: [ [&apos;Javascript&apos;, &apos;jQuery&apos;, &apos;CSS&apos;, &apos;ES6&apos;, &apos;Node&apos;], [&apos;Webpack&apos;, &apos;Gulp&apos;], [&apos;Less&apos;,&apos;Sass&apos;], [&apos;Git&apos;, &apos;SVN&apos;], [&apos;Vue&apos;], [&apos;GLang&apos;] ], devTools: [ [ &apos;Visual Studio Code&apos;, &apos;GoLand&apos;， &apos;Atom&apos;, &apos;Sublime Text&apos;], [&apos;Chrome DevTools&apos;], [&apos;SourceTree&apos;, &apos;Iterm&apos;],, [&apos;Navicat&apos;, &apos;Robot&apos;], ] &#125;"},{"title":"Repositories","date":"2018-03-31T14:07:42.000Z","updated":"2018-03-28T06:01:11.000Z","comments":false,"path":"repository/index.html","permalink":"http://charlycheng.xyz/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-03-31T14:07:42.000Z","updated":"2018-03-28T05:50:01.000Z","comments":false,"path":"categories/index.html","permalink":"http://charlycheng.xyz/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2018-03-31T14:07:42.000Z","updated":"2018-03-28T06:01:40.000Z","comments":false,"path":"books/index.html","permalink":"http://charlycheng.xyz/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-03-31T14:07:42.000Z","updated":"2018-03-28T05:00:59.000Z","comments":true,"path":"links/index.html","permalink":"http://charlycheng.xyz/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-03-31T14:07:42.000Z","updated":"2018-03-28T05:03:08.000Z","comments":false,"path":"tags/index.html","permalink":"http://charlycheng.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode 无重复字符的最长子串","slug":"3_4无重复字符的最长子串","date":"2018-04-21T12:42:02.000Z","updated":"2018-04-21T12:42:02.000Z","comments":true,"path":"2018/04/21/3_4无重复字符的最长子串/","link":"","permalink":"http://charlycheng.xyz/2018/04/21/3_4无重复字符的最长子串/","excerpt":"","text":"概要定义两个变量res和left，其中res用来记录最长无重复子串的长度，lefts指向该无重复子串左边的起始位置，然后我们遍历整个字符串，对于每一个遍历到的字符，如果哈希表中该字符串对应的值为0，说明没有遇到过该字符，则此时计算最长无重复子串，i - left +１，其中ｉ是最长无重复子串最右边的位置，left是最左边的位置，还有一种情况也需要计算最长无重复子串，就是当哈希表中的值小于left，这是由于此时出现过重复的字符，left的位置更新了，如果又遇到了新的字符，就要重新计算最长无重复子串。最后每次都要在哈希表中将当前字符对应的值赋值为i+1 无重复字符的最长子串给定一个字符串，找出不含有重复字符的最长子串的长度。示例：12345给定 &quot;abcabcbb&quot; ，没有重复字符的最长子串是 &quot;abc&quot; ，那么长度就是3。给定 &quot;bbbbb&quot; ，最长的子串就是 &quot;b&quot; ，长度是1。给定 &quot;pwwkew&quot; ，最长子串是 &quot;wke&quot; ，长度是3。请注意答案必须是一个子串，&quot;pwke&quot; 是 子序列 而不是子串。 解法112345678910111213141516171819202122232425262728/** * @param &#123;string&#125; s * @return &#123;number&#125; */ var lengthOfLongestSubstring = function(s) &#123; let hash = &#123;&#125; let start = 0 let ans = 0 for (var i = 0; i &lt; s.length; i++)&#123; let item = s[i] if (!hash[item]) &#123; hash[item] = true &#125; else &#123; for (;;) &#123; if (s[start] === item) &#123; start++; break; &#125; hash[s[start]] = false start++ &#125; &#125; ans = Math.max(ans, i - start + 1) &#125; return ans &#125; 解法二下面这种写法是上面解法的精简模式，思路都一样：123456789101112var lengthOfLongestSubstring = function(s) &#123; var res = 0 var left = -1 var m = [] m.fill(-1) for (var i = 0; i &lt; s.length; i++) &#123; left = Math.max(left, m[s.charAt(i)]) m[s.charAt[i]] = i res = Math.max(res, i - left) &#125; return res&#125; 解法三下面这种解法使用了set，核心算法和上面的很类似，把出现过的字符都放入set中，遇到set中没有的字符就加入set中并更新结果res，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止：123456789101112131415var lengthOfLongestSubstring = function(s) &#123; var res = 0 var left = 0 var right = 0 var t = new Set() while (right &lt; s.length)&#123; if (!t.has(s.charAt(right))) &#123; t.add(s.charAt(right++)) res = Math.max(res, t.size) &#125; else &#123; t.delete(s.charAt(left++)) &#125; &#125; return res&#125; 两个排序数组的中位数给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n))示例 1:1234nums1 = [1, 3]nums2 = [2]中位数是 2.0示例 2:123nums1 = [1, 2]nums2 = [3, 4]中位数是 (2 + 3)/2 = 2.5 解题思路这道题让我们求两个有序数组的中位数，而且限制了时间复杂度为O(log (m+n))，看到这个时间复杂度，自然而然的想到了应该使用二分查找法来求解。但是这道题被定义为Hard也是有其原因的，难就难在要在两个未合并的有序数组之间使用二分法，这里我们需要定义一个函数来找到第K个元素，由于两个数组长度之和的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。下面重点来看如何实现找到第K个元素，首先我们需要让数组1的长度小于或等于数组2的长度，那么我们只需判断如果数组1的长度大于数组2的长度的话，交换两个数组即可，然后我们要判断小的数组是否为空，为空的话，直接在另一个数组找第K个即可。还有一种情况是当K = 1时，表示我们要找第一个元素，只要比较两个数组的第一个元素，返回较小的那个即可。 解法112345678910var findMedianSortedArrays = function(nums1, nums2) &#123; var s = nums1.concat(nums2); s.sort(function(a, b) &#123; return a - b; &#125;); var len = s.length; if (len &amp; 1) return s[~~(len / 2)]; else return (s[len / 2 - 1] + s[len / 2]) / 2;&#125;; 解法2此题还能用二分搜索法来解，是一种相当巧妙的应用，讲解在这个帖子中写的十分清楚，等有时间我再来写写分析过程：123456789101112131415161718192021222324252627var findMedianSortedArrays = function(nums1, nums2) &#123; var m = nums1.length; var n = nums2.length; if (m &lt; n) &#123; return findMedianSortedArrays(nums2, nums1) &#125; if (n == 0) &#123; return (nums1[(m - 1) / 2] + nums1[m / 2]) / 2.0 &#125; var left = 0, right = 2 * n while (left &lt;= right) &#123; var mid2 = (left + right) / 2; var mid1 = m + n - mid2; var L1 = mid1 == 0 ? 0 : nums1[(mid1 - 1) / 2]; var L2 = mid2 == 0 ? 0 : nums2[(mid2 - 1) / 2]; var R1 = mid1 == m * 2 ? 0 : nums1[mid1 / 2]; var R2 = mid2 == n * 2 ? 0 : nums2[mid2 / 2]; if (L1 &gt; R2) &#123; left = mid2 + 1; &#125;else if (L2 &gt; R1) &#123; right = mid2 - 1; &#125;else &#123; return (Math.max(L1, L2) + Math.min(R1, R2)) / 2; &#125; &#125;&#125;;","categories":[{"name":"算法、数据","slug":"算法、数据","permalink":"http://charlycheng.xyz/categories/算法、数据/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://charlycheng.xyz/tags/leetcode/"}]},{"title":"leetcode 两数之和/两数相加","slug":"1_2AddTwo_Sum","date":"2018-04-21T12:42:02.000Z","updated":"2018-04-21T12:42:02.000Z","comments":true,"path":"2018/04/21/1_2AddTwo_Sum/","link":"","permalink":"http://charlycheng.xyz/2018/04/21/1_2AddTwo_Sum/","excerpt":"","text":"概要前端对算法的需求一直是最少的，接触的无非是一些冒泡排序之类的简单算法，最近面试感触良多，不说面试算法已经是必考的题目，就说能够加深对Js的理解，也是要仔细看下立个flag，对leetcode Js刷题，估计之后会再用GoLang走一遍 两数之和给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。示例：1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 直观暴力解法，双重循环耗时：88ms1234567891011121314/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; for (var j = i+1; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] === target) &#123; return [i, j] &#125; &#125; &#125;&#125;;这也是我的第一种解法，明显不符合面试官的要求，这个算法的时间复杂度是O(n^2)。那么只能想个O(n)的算法来实现， 字典查找整个实现步骤为：先遍历一遍数组，建立map数据，然后再遍历一遍，开始查找，找到则记录index。代码如下：耗时：88ms12345678910var twoSum = function(nums, target) &#123; let m = &#123;&#125;; for (var i = 0; i &lt; nums.length; i++) &#123; let tmp = target - nums[i] if (m[tmp] !== undefined) &#123; return [m[tmp], i] &#125; m[nums[i]] = i &#125;&#125;; 两数相加给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807这道题主要考察连接结构，对链表结构并不熟悉，所以想起来有问题，下面的解法有用的位运算符等1234567891011121314151617181920212223242526272829303132333435var addTwoNumbers = function(l1, l2) &#123; var add = 0 , ans , head; while(l1 || l2) &#123; var a = l1 ? l1.val : 0 , b = l2 ? l2.val : 0; var sum = a + b + add; add = ~~(sum / 10); var node = new ListNode(sum % 10); if (!ans) ans = head = node; else &#123; head.next = node; head = node; &#125; if (l1) l1 = l1.next; if (l2) l2 = l2.next; &#125; if (add) &#123; var node = new ListNode(add); head.next = node; head = node; &#125; return ans;&#125;;","categories":[{"name":"算法、数据","slug":"算法、数据","permalink":"http://charlycheng.xyz/categories/算法、数据/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://charlycheng.xyz/tags/leetcode/"}]},{"title":"Vue双向绑定原理及实现","slug":"Vue双向绑定——一步一步实现","date":"2018-04-20T07:00:16.000Z","updated":"2018-04-21T12:42:02.000Z","comments":true,"path":"2018/04/20/Vue双向绑定——一步一步实现/","link":"","permalink":"http://charlycheng.xyz/2018/04/20/Vue双向绑定——一步一步实现/","excerpt":"","text":"深入响应式原理Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，将进入一些 Vue 响应式系统的底层的细节。 追踪变化普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter，在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新响应原理图 简单实现双向绑定基本实现：var obj = { };Object.defineProperty(obj, “hello”, {get: function () {return sth},set: function (val) {do sth}})obj.hello // 可以像普通属性一样读取访问器属性访问器属性的&quot;值&quot;比较特殊，读取或设置访问器属性的值，实际上是调用其内部特性：get和set函数。obj.hello // 读取属性，就是调用get函数并返回get函数的返回值obj.hello = “abc” // 为属性赋值，就是调用set函数，赋值其实是传参此例实现的效果是：随文本框输入文字的变化，span 中会同步显示相同的文字内容；在js或控制台显式的修改 obj.hello 的值，视图会相应更新。这样就实现了 model =&gt; view 以及 view =&gt; model 的双向绑定。123456789101112131415161718&lt;input type=&quot;text&quot; id=&quot;a&quot; /&gt;&lt;span id=&quot;b&quot;&gt;&lt;/span&gt;&lt;script&gt; var obj = &#123;&#125; Object.defineProperty(obj, &quot;hello&quot;, &#123; get: function() &#123; console.log(&quot;get方法被调用了&quot;) &#125;, set: function(newVal) &#123; document.getElementById(&quot;a&quot;).value = newVal document.getElementById(&quot;b&quot;).innerHTML = newVal &#125; &#125;) document.addEventListener(&quot;keyup&quot;, function (e)&#123; obj.hello = e.tartget.value &#125;)&lt;/script&gt; 真正实现Vue的双向绑定页面结构：1234567&lt;div id=&quot;app&quot;&gt; &lt;form&gt; &lt;input type=&quot;text&quot; v - model=&quot;number&quot;&gt; &lt; button type=&quot;button&quot; v - click=&quot;increment&quot;&gt;增加&lt;/ button&gt; &lt;/form&gt; &lt;h3 v - bind=&quot;number&quot;&gt;&lt;/h3&gt;&lt;/div&gt;最后会通过类似于vue的方式来使用我们的双向数据绑定，结合我们的数据结构添加注释1234567891011var app = new myvue(&#123; el: &quot;#app&quot;, data: &#123; number: 0 &#125;, methods: &#123; increment: function() &#123; this.number++ &#125; &#125;&#125;)首先定义一个myVue构造函数：123function MyVue(options)&#123;&#125;初始化这个构造函数，添加_init 属性：123456789function myVue(options) &#123;&#125;myvue.prototype._init = function (options) &#123; this.$options = options this.$el = document.querySelector(options.el) this.$data = options.data this.$methods = options.methods&#125;接下来实现_obverse函数， 对data进行处理， 重写data的set和get函数， 并改造_init函数123456789101112131415161718192021222324252627282930313233myvue.prototype._obverse = function (obj) &#123; var value for (key in obj) &#123; if (obj.hasOwnproperty(key))&#123; value = obj[key] if (typeof value === &quot;object&quot;) &#123; this._obverse(value) &#125; Object.defineProperty(this.$data, key, &#123; enumerable: true, configurable: true, get: function() &#123; console.log(`获取$&#123;value&#125;`) return value &#125;, set: function(newVal) &#123; console.log(`更新$&#123;newVal&#125;`) if (value !== newVal) &#123; value = newVal &#125; &#125; &#125;) &#125; &#125;&#125;myvue.prototype._init = function (options) &#123; this.$options = options this.$el = document.querySelector(options.el) this.$data = options.data this.$methods = options.methods this._obverse(this.$data)&#125;","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://charlycheng.xyz/categories/前端开发/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://charlycheng.xyz/tags/vue/"}]},{"title":"Promise/A+源码实现及平时常见问题","slug":"promise:A+源码实现及平时常见问题","date":"2018-04-19T14:05:13.000Z","updated":"2018-04-19T14:05:13.000Z","comments":true,"path":"2018/04/19/promise:A+源码实现及平时常见问题/","link":"","permalink":"http://charlycheng.xyz/2018/04/19/promise:A+源码实现及平时常见问题/","excerpt":"","text":"Promisepromise是解决回调的问题的，通过then的链式调用，让我们能更清晰的理解阅读代码，下面我们剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类。 Promise标准解读 常用词汇解释：1.1 “promise”是一个对象或函数，它的行为符合这个规范1.2 “thenable”是定义then方法的对象或函数1.3 “value”是任何合法的JavaScript值（包括undefined，thenable或promise）1.4 “异常”是使用throw语句抛出的值1.5 “原因”是一个值（结果）表明promise被拒绝的原因 常用promise要求：2.1 一个promise必须包含初始态, 成功（完成）态, 或者失败（拒绝）态这三个状态中的一种2.2 当状态是初始态, promise可能转换到成功态或失败态。2.3 当状态是成功态或者失败态，promise不能更改成别的状态，必须有个不能更改的值（结果）或者不能更改的失败（错误）原因2.4 上面“不能改变”的意思是不可改变的状态（即 ===），但并不意味着深不可变。2.5 一个promise必须有一个then方法来获取成功的值（结果）或失败（错误）的原因。一个promise方法接收两个参数：promise.then(onFulfilled, onRejected)2.6 onFulfilled和onRejected都是可选参数：如果onFulfilled不是函数，则必须忽略它。如果onRejected不是函数，则必须忽略它。2.7 如果onFulfilled是一个函数：必须在promise执行完成后调用，promise的返回值作为第一个参数。在promise执行前不得调用。只能调用一次。2.8 如果onRejected是一个函数：必须在promise执行完成后调用，promise的错误原因作为第一个参数。在promise执行前不得调用。只能调用一次。2.9 在执行上下文堆栈仅包含平台代码之前，不能调用onFulfilled或onRejected3.0 onFulfilled和onRejected必须是函数（即 没有这个值）3.1 then方法可能会在相同的promise被多次调用。如果/当promise成功时，所有各自的onFulfilled回调必须按照其始发调用的顺序执行。如果/当promise失败时，所有各自的onRejected回调必须按照其始发调用的顺序执行3.2 then方法必须返回一个promise。例如：promise2 = promise1.then(onFulfilled, onRejected);如果onFulfilled或onRejected引发异常e，promise2必须以e作为拒绝原因如果onFulfilled不是一个函数并且promise1是被成功，那么promise2必须用与promise1相同的值执行。如果onRejected不是函数并且promise1是被失败，那么promise2必须用与promise1相同的失败原因。3.3 Promise的解决程序是一个抽象操作，取得输入的promise和一个值（结果），我们表示为 Resolve(promise, x)。Resolve(promise, x)的意思是创建一个方法Resolve方法执行时传入两个参数promise和x（promise成功态时返回的值）。如果x是一个thenable（见上文术语1.2），它试图创造一个promise采用x的状态，假设x的行为至少貌似promise。否则，它用x值执行promise。3.4 对thenable的这种处理允许promise实现交互操作，只要它们暴露Promise / A +兼容的方法即可。 它还允许Promises / A +实现通过合理的方法“吸收”不合格的实现3.5 去运行 [[Resolve]](promise, x)，需执行以下步骤：如果promise和x引用同一个对象，则以TypeError为原因拒绝promise3.6 如果x是一个promise，采用它的状态：如果x是初始态，promise必须保持初始态(即递归执行这个解决程序)，直到x被成功或被失败。（即，直到resolve或者reject执行）如果/当x被成功时，用相同的值（结果）履行promise。如果/当x被失败时，用相同的错误原因履行promise。3.7 否则，如果x是一个对象或函数,让then等于x.then。如果x.then导致抛出异常e，拒绝promise并用e作为失败原因。如果then是一个函数，则使用x作为此参数调用它，第一个参数resolvePromise，第二个参数rejectPromise，其中：如果使用值（结果）y调用resolvePromise，运行[[Resolve]]（promise，y）我的解决程序的名字是resolveExecutor。如果使用拒绝原因r调用resolvePromise，运行reject®。如果resolvePromise和rejectPromise都被调用，或者对同一个参数进行多次调用，则第一次调用优先，并且任何进一步的调用都会被忽略。如果调用then方法抛出异常e，如果resolvePromise或rejectPromise已经调用了，则忽略它。否则，以e作为失败原因拒绝promise。如果then不是一个对象或者函数，则用x作为值（结果）履行promise。3.8 如果x不是一个对象或函数，则用x作为值履行promise。如果一个primse是通过一个thenable参与一个循环的可链接表达式来解决的thenable链，那么[[Resolve]]（promise，thenable）的递归性质最终会导致[[Resolve]]（promise，thenable）被再次调用， 上述算法将导致无限递归。 支持这种实现，但不是必需的，来检测这种递归并以一个信息性的TypeError为理由拒绝promise。 Promise 实现 构造函数因为标准并没有指定如何构造一个Promise对象，所以我们同样以目前一般Promise实现中通用的方法来构造一个Promise对象，也是ES6原生Promise里所使用的方式，即：1234567// Promise构造函数接收一个executor函数，executor函数执行完同步或异步操作后，调用它的两个参数resolve和rejectvar promise = new Promise(function(resolve, reject) &#123; /* 如果操作成功，调用resolve并传入value 如果操作失败，调用reject并传入reason */&#125;)我们先实现构造函数的框架如下：123456789function Promise(executor) &#123; var self = this; //缓存this self.status = &quot;pending&quot; //设置初始态 self.value = undefined //定义成功的值默认undefined self.reason = undefined //定义失败的原因默认undefined self.onResolvedCallbacks = []//定义成功的回调数组 self.onRejectedCallbacks = []//定义失败的回调数组 executor (resolve, reject)&#125;上面的代码基本实现了Promise构造函数的主体，但目前还有两个问题：我们给executor函数传了两个参数：resolve和reject，这两个参数目前还没有定义executor有可能会出错（throw），类似下面这样，而如果executor出错，Promise应该被其throw出的值reject：new Promise(function(resolve, reject) {throw 2})所以我们需要在构造函数里定义resolve和reject这两个函数：基本上就是在判断状态为pending之后把状态改为相应的值，并把对应的value和reason存在self的value与reason属性上面，之后执行相应的回调函数，逻辑很简单，这里就不多解释了。123456789101112131415161718192021222324252627282930313233343536function Promise(executor) &#123; var self = this; //缓存this self.status = &quot;pending&quot; //设置初始态 self.value = undefined //定义成功的值默认undefined self.reason = undefined //定义失败的原因默认undefined self.onResolvedCallbacks = []//定义成功的回调数组 self.onRejectedCallbacks = []//定义失败的回调数组 let resolve = (value) =&gt; &#123; if (value instanceof MyPromise) return value.then(resolve, reject) setTimeout( () =&gt; &#123; if (self.status === &quot;pending&quot;) &#123; self.status = &quot;fulfilled&quot; self.value = value self.onResolvedCallbacks.forEach ((onFulfilled) =&gt; &#123; onFulfilled(value) &#125;) &#125; &#125;) &#125; let reject = (reason) =&gt; &#123; setTimeout ( () =&gt; &#123; if (self.status === &quot;pending&quot;) &#123; self.status = &quot;reject&quot; self.value = value self.onRejectedCallbacks.forEach ((onRejected) =&gt; &#123; onRejected(reason) &#125;) &#125; &#125;) &#125; try &#123; executor (resolve, reject) &#125; catch (e) &#123; reject (e) &#125;&#125; then方法Promise对象有一个then方法，用来注册在这个Promise状态确定后的回调，很明显，then方法需要写在原型链上。then方法会返回一个Promise，关于这一点，Promise/A+标准并没有要求返回的这个Promise是一个新的对象，但在Promise/A标准中，明确规定了then要返回一个新的对象，目前的Promise实现中then几乎都是返回一个新的Promise(详情)对象，所以在我们的实现中，也让then返回一个新的Promise对象。12345678910111213141516171819Promise.prototype.then = (onResolved = (value) =&gt; &#123;value&#125;, onRejected = (reason) =&gt; &#123;throw reason&#125;) =&gt; &#123; let self = this; let promise2 if (self.status === \"pending\") &#123; return (promise2 = new Promise((resolve, reject) =&gt; &#123; &#125;)) &#125; if (self.status === \"rejected\") &#123; return (promise2 = new Promise((resolve, reject) =&gt; &#123; &#125;)) &#125; if (self.status === \"fulfilled\") &#123; return (promise2 = new Promise((resolve, reject) =&gt; &#123; &#125;)) &#125;&#125;Promise总共有三种可能的状态，我们分三个if块来处理，在里面分别都返回一个new Promise。根据标准，我们知道，对于如下代码，promise2的值取决于then里面函数的返回值:12345promise2 = promise1.then(function(value) &#123; return 4&#125;, function(reason) &#123; throw new Error('sth went wrong')&#125;)需要在then里面执行onResolved或者onRejected，并根据返回值(标准中记为x)来确定promise2的结果，并且，如果onResolved/onRejected返回的是一个Promise，promise2将直接取这个Promise的结果：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Promise.prototype.then = (onResolved = (value) =&gt; &#123;value&#125;, onRejected = (reason) =&gt; &#123;throw reason&#125;) =&gt; &#123; let self = this; let promise2 if (self.status === \"pending\") &#123; return (promise2 = new Promise((resolve, reject) =&gt; &#123; self.onResolvedCallbacks.push(() =&gt; &#123; try &#123; let x = onfulfilled(self.value) resolveExecutor(promise2, x , resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;); self.onRejectedCallbacks.push(() =&gt; &#123; try &#123; let x = onRejected(self.reason) resolveExecutor(promise2, x , resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;); &#125;)) &#125; if (self.status === \"rejected\") &#123; return (promise2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.reason) resolveExecutor(promise2, x , resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;); &#125;)) &#125; if (self.status === \"fulfilled\") &#123; return (promise2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onfulfilled(self.value) resolveExecutor(promise2, x , resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;); &#125;)) &#125; static catch(onRejected) &#123; this.then(null, onRejected) &#125; static resolve(value) &#123; return new MyPromise(resolve =&gt; &#123; resolve(value) &#125;) &#125; static reject(reason) &#123; return new MyPromise(resolve =&gt; &#123; reject(value) &#125;) &#125; static all(promises) &#123; return new MyPromise((resolve, reject) =&gt; [ let len = promises.length let resolveAry = [] let count = 0 for (let i = 0; i&lt; len; i++) &#123; promises[i].then(value =&gt; &#123; resolveAry[i] = value if (++count === len) resolve(resolveAry) &#125;, reject) &#125; ]) &#125; static race (promises) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let i = 0, l = promises.length; i &lt; l;i++) &#123; promises[i].then(resolve, reject) &#125; &#125;) &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344//promise主要解决程序，也是promise的难点let resolveExecutor = (promise2, x, reslove, reject) =&gt; &#123; let isThenCalled = false // 定义个标识 promise2是否已经resolve 或 reject了 if (promise2 === x) &#123; //如果promise和x引用同一个对象，则以TypeError为原因拒绝promise return reject(new TypeError(\"循环引用！！！\")) &#125; if (x instanceof MyPromise) &#123; //如果x是一个promise，采用它的状态 if (x.status === \"pending\") &#123; //如果x是初始态，promise必须保持初始态(即递归执行这个解决程序)，直到x被成功或被失败。（即，直到resolve或者reject执行） x.then(function(y)&#123; resolveExecutor(promise2, y , resolve, reject) &#125;, reject) &#125; else &#123; //如果/当x被成功时，用相同的值（结果）履行promise。 //如果/当x被失败时，用相同的错误原因履行promise x.then(resolve, reject) &#125; &#125; else if (x !== null &amp;&amp; (typeof x === \"object\" || typeof x === \"function\"))&#123; //否则，如果x是一个对象或函数, try &#123; let then = x.then if (typeof then === \"function\") &#123; let resolvePromise = y =&gt; &#123; if (isThencalled)&#123;return&#125; isThenCalled = true resolveExecutor(promise2, y, resolve, reject) &#125; let rejectPromise = r =&gt; &#123; if (isThencalled)&#123;return&#125; isThenCalled = true reject(r) &#125; then.call(x, resolvePromise, rejectPromise) &#125; else &#123; //到此的话x不是一个thenable对象，那直接把它当成值resolve promise2就可以了 resolve(x) &#125; &#125; catch (e) &#123; if (isThenCalled) return isThenCalled = true reject(e) &#125; &#125;else &#123; resolve(x) &#125;&#125;至此，我们基本实现了Promise标准中所涉及到的内容，但还有几个问题 关于Promise的其它问题Promise的性能问题如何停止一个Promise链？Promise链上返回的最后一个Promise出错了怎么办？Angular里的$q跟其它Promise的交互出错时，是用throw new Error()还是用return Promise.reject(new Error())呢？ 最佳实践1.一是不要把Promise写成嵌套结构2.二是链式Promise要返回一个Promise，而不只是构造一个Promise 总结一步一步实现promisepromise原文解读","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://charlycheng.xyz/categories/前端开发/"}],"tags":[{"name":"promise","slug":"promise","permalink":"http://charlycheng.xyz/tags/promise/"}]},{"title":"浅谈函数节流与防抖","slug":"函数防抖及节流","date":"2018-04-10T00:01:30.000Z","updated":"2018-04-10T00:01:30.000Z","comments":true,"path":"2018/04/10/函数防抖及节流/","link":"","permalink":"http://charlycheng.xyz/2018/04/10/函数防抖及节流/","excerpt":"","text":"概述函数节流(throttle)的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。函数去抖(debounce)就是对于一定时间段的连续的函数调用，只让其执行一次。 应用场景throttle 和 debounce 的应用场景应该是分的很清楚的1.按一个按钮发送 AJAX：给 click 加了 debounce 后就算用户不停地点这个按钮，也只会最终发送一次；如果是 throttle 就会间隔发送几次2.监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次 函数去抖示例以 scroll 事件为例，探究如何实现滚动一次窗口打印一个 hello world 字符串。如果不对其节流或者去抖控制123window.onscroll = function() &#123; console.log(&apos;hello world&apos;);&#125;;这样每滚动一次，实际上会打印 N 多个 hello world。函数去抖背后的基本思想是指，某些代码不可以在没有间断的情况连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。《高程三》给出了最简洁最经典的去抖代码（书中说是节流，实则为去抖），调用如下：1234567891011121314function debounce(method, context) &#123; clearTimeout(method.iTd) method.iTd = setimeout(function()&#123; method.call(context) &#125;, 1000)&#125;function print () &#123; console.log(&quot;hello world&quot;)&#125;window.onscroll = function () &#123; debounce(print)&#125;在窗口内滚动一次，停止，1000ms 后，打印了 hello world，因为我们设置了一个 1000ms 延迟的定时器，细思非常巧妙。看官观察下另一个版本：1234567891011121314151617function debounce(method, context) &#123; var timer = null return function () &#123; clearTimeout(timer) timer = setimeout(function()&#123; method.call(context) &#125;, 1000) &#125;&#125;function print () &#123; console.log(&quot;hello world&quot;)&#125;window.onscroll = function () &#123; debounce(print)&#125;从这个意义上讲，闭包其实就是用来将两个内容隔离用的，将 timer 放入函数中，那么就需要将原来的语句放入函数中，使其与 timer 隔离，最近返回这个函数。结果就会和原来的效果是一样的。underscore 在其基础上进行了扩充，直接看代码，含大量注释：12345678910111213141516171819202122232425262728293031_.debounce = function (func, wait, immediate) &#123; var timeout, args, context, timestamp, result var later = function () &#123; var last = _.now() - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = seTimeout(later, wait - last) &#125;else &#123; timeout = null if (!immediate)&#123; result = func.apply(context, args) if (!timeout) &#123; context = args = null &#125; &#125; &#125; &#125; return function() &#123; context = this; args = arguments; timestamp = _.now(); var callNow = immediate %% !timeout if (!timeout) &#123; timeout = seTimeout(later, wait) &#125; if (callaNow) &#123; result = func.apply(context, args) context = args = null &#125; return result &#125;&#125;当然，除了功能上的优势，性能也是提高不少，最显而易见的是基础版每此触发事件都会取消定时器，然后重新设置定时器，而 underscore 中会在一定时间后才取消定时器，重新设置定时器 函数节流示例某些代码不可以在没有间断的情况连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。函数节流的基本模式12345678910111213var processor = &#123; timeoutId : null, performing: function&#123; //实际执行代码 &#125;， process: function () &#123; clearTimeout( this.timeoutId) var that = this; this.timeoutId = seTimeout(function()&#123; that.performing(); &#125;,100) &#125;&#125;已常见的搜索功能测试1234567891011HTMl： &lt;input id=&quot;search&quot; type=&quot;text&quot; name=&quot;search&quot;&gt;JS： &lt;script&gt; function queryData(text)&#123; console.log(&quot;搜索：&quot; + text); &#125; var input = document.getElementById(&quot;search&quot;); input.addEventListener(&quot;keyup&quot;, function(event)&#123; queryData(this.value); &#125;); &lt;/script&gt;这种情况下，每按下一个键盘键，就输出了一次。短短的一些内容，输出了14次，如果每一次都是一次ajax查询请求的话就发了14个请求了。在性能上的消耗可想而知。使用函数节流模式的情况：1234567891011121314151617181920HTML： &lt;input id=&quot;search&quot; type=&quot;text&quot; name=&quot;search&quot;&gt;JS： &lt;script&gt; function queryData(text)&#123; console.log(&quot;搜索：&quot; + text); &#125; var input = document.getElementById(&quot;search&quot;); input.addEventListener(&quot;keyup&quot;, function(event)&#123; throttle(queryData, null, 500, this.value); // queryData(this.value); &#125;); function throttle(fn,context,delay,text)&#123; clearTimeout(fn.timeoutId); fn.timeoutId = setTimeout(function()&#123; fn.call(context,text); &#125;,delay); &#125; &lt;/script&gt;这种情况下，输入了好一些内容，只输出了一次，因为测试的时候设置了两次输入间隔是500ms，实际应用可根据情况设置。显然，这在性能上大大滴得到了优化。不过，这样的话，有一个新问题两次之间的输入间隔都小于自己设置的delay值，那么，这个queryData搜索函数就一直得不到调用。实际上，我们更希望的是，当达到某个时间值时，一定要执行一次这个搜索函数。所以，就有了函数节流的改进模式12345678910111213141516171819202122232425function queryData(text)&#123; console.log(&quot;搜索：&quot; + text);&#125;var input = document.getElementById(&quot;search&quot;);input.addEventListener(&quot;keyup&quot;, function(event)&#123; throttle(queryData, null, 500, this.value,1000);&#125;);function throttle (fn, context, delay, text, mustApplyTime)&#123; clearTimeout(fn.timer); fn._cur = Date.now(); //记录当前时间 if(!fn._start) &#123; //若该函数是第一次调用，则直接设置_start,即开始时间，为_cur，即此刻的时间 fn._start = fn._cur; &#125; if(fn._cur - fn._start &gt; mustApplyTime)&#123; //当前时间与上一次函数被执行的时间作差，与mustApplyTime比较，若大于，则必须执行一次函数，若小于，则重新设置计时器 fn.call (context, text); fn._start = fn._cur; &#125;else &#123; fn.timer = setTimeout(function()&#123; fn.call(context, text); &#125;,deley); &#125;&#125; 更多学习链接节流与去抖","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://charlycheng.xyz/categories/前端开发/"}],"tags":[{"name":"js","slug":"js","permalink":"http://charlycheng.xyz/tags/js/"}]},{"title":"Hexo 主题pure使用及修改记录","slug":"Hexo 主题pure使用及修改记录","date":"2018-03-29T02:05:22.000Z","updated":"2018-04-01T06:47:14.000Z","comments":true,"path":"2018/03/29/Hexo 主题pure使用及修改记录/","link":"","permalink":"http://charlycheng.xyz/2018/03/29/Hexo 主题pure使用及修改记录/","excerpt":"","text":"主题效果具体效果请到我的博客查看 配置说明在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件 启用pure主题 安装主题1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure打开站点配置文件，找到theme字段，将其值更改为 pure1theme: next更新主题12cd themes/puregit pull到此，主题安装完成。然后启动Hexo服务验证主题是否正确启用。1hexo s使用浏览器访问[http://localhost:4000],检查主体是否被启用 主题设定 设置语言打开站点配置文件, 将 language 设置成你所需要的语言。建议明确设置你所需要的语言,可选值对应themes\\pure\\languages目录下语言文件，简体中文配置如下：1language: zh-CN 设置个人信息123头像在themes\\pure\\source\\images 目录下替换图片即可，捐献的二维码同理。个人信息大部分都在 主题配置文件 中设置 设置菜单右边导航菜单在主题配置文件中配置12345678910111213141516171819202122# 导航菜单menu: Home: . Archives: archives # 归档 Categories: categories # 分类 Tags: tags # 标签 Repository: repository # github repositories Books: books # 书单 Links: links # 友链 About: about # 关于# 导航菜单图标（font awesome）menu_icons: enable: true # 是否启用菜单图标 home: fa-dashboard archives: fa-delicious categories: fa-folder tags: fa-tags repository: fa-code books: fa-leanpub links: fa-gg about: fa-coffee 添加背景动画背景动画基于canvas，在\\themes\\pure\\layout\\layout.ejs的中面添加1&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; 站点建立时间这个时间将在站点的底部显示，例如 © 2017。 编辑 主题配置文件，新增字段 since。配置示例1since: 2017 添加404公益页面新建 404.html 页面，放到主题的 source 目录下，内容如下：123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;回到我的主页&quot;&gt; &lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 阅读次数统计不蒜子，在主题配置文件 中把busuanzi设置为true即可：123pv: busuanzi: enable: true # 不蒜子统计 常用插件及用法 hexo-wordcount简介：为文章添加文章字数统计、文章预计阅读时间1npm install hexo-wordcount --save配置：在主题配置文件 中设置为true：12345# wordcountpostCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 hexo-douban简介：为博客添加豆瓣书单和豆瓣电影。（不支持分页，数据大网络差有可能出现超时错误）1npm install hexo-douban --save配置：在站点配置文件 _config.yml中添加12345678douban: user: 豆瓣个性域名 book: title: &apos;This is my book title&apos; quote: &apos;This is my book quote&apos; movie: title: &apos;This is my movie title&apos; quote: &apos;This is my movie quote&apos;主题已经默认添加了豆瓣书单，豆瓣电影自己配置 hexo-autonofollow简介：自动为站外链接添加nofollow属性1npm install hexo-autonofollow --save配置：在站点配置文件_config.yml中添加12345nofollow: enable: true exclude: - exclude1.com - exclude2.com hexo-generator-feed简介：RSS的生成插件，你可以在配置显示你站点的RSS，文件路径\\atom.xml。1npm install hexo-generator-feed --save配置：在站点配置文件_config.yml中添加123456feed: type: atom path: atom.xml limit: 20 hub: content: hexo-generator-sitemap简介：生成博客的sitemap1npm install hexo-generator-sitemap --save配置：在站点配置文件_config.yml中添加12sitemap: path: sitemap.xml hexo-generator-baidu-sitemap简介：生成博客的sitemap（针对百度）。1npm install hexo-generator-baidu-sitemap --save配置：在站点配置文件_config.yml中添加12baidusitemap:path: baidusitemap.xml hexo-generator-json-content简介：用于生成静态站点数据，提供搜索功能的数据源。1npm install hexo-generator-json-content --save配置：在站点配置文件_config.yml中添加1234567jsonContent: ignore: - path/to/a/page - url/to/one/post - an-entire-category - specific.file - .ext # a file extension hexo-neat简介：自动压缩html、css、js代码1npm install hexo-neat --save配置：在站点配置文件_config.yml中添加123456789101112131415neat_enable: trueneat_html: enable: ture exclude:neat_css: enable: true exclude: - &apos;*.min.css&apos;neat_js: enable: true mangle: true output: compress: exclude: - &apos;*.min.js&apos; 参考http://www.wanghongbin.tophttp://blog.cofess.com/2017/11/01/hexo-blog-theme-pure-usage-description.html 总结Blog 主题更替了好几次，最终选择这款主题，简洁明了，让人喜欢！","categories":[{"name":"技术杂记","slug":"技术杂记","permalink":"http://charlycheng.xyz/categories/技术杂记/"}],"tags":[{"name":"hexo pure","slug":"hexo-pure","permalink":"http://charlycheng.xyz/tags/hexo-pure/"}]},{"title":"vue引入swiper实现轮播图","slug":"vue引入swiper","date":"2018-03-29T01:46:59.000Z","updated":"2018-04-01T06:08:43.000Z","comments":true,"path":"2018/03/29/vue引入swiper/","link":"","permalink":"http://charlycheng.xyz/2018/03/29/vue引入swiper/","excerpt":"","text":"图片轮播是前端中经常需要实现的一个功能，因为需要实现年度H5传播,实现滑动切换、动画等功能。考察过vue-awesome-swiper/vue-swiper等封装的库，都会出现一些问题，而且自己的业务代码Vue1.0，最后选择swiper.js Swiper Swiper的具体使用教程及详细API，参考Swiper中文网Swiper是纯Javascript打造的滑动特效插件，面向手机、平板电脑等移动终端。Swiper能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。Swiper开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择 一、引入swiper安装swiper1npm install --save swiper引用两个文件12import Swiper from \"swiper\";import \"swiper/dist/css/swiper.min.css\"; 二、HTML代码12345678910&lt;template&gt; &lt;div class=\"swiper-container\" :class=\"swipeid\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;!-- 存放具体的轮播内容 --&gt; &lt;slot name =\"swiper-con\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;!-- 分页器 --&gt; &lt;div :class=\"&#123;'swiper-pagination':pagination&#125;\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 三、初始化swiper初始化之前，根据Swiper用法的了解，先确定轮播组件需要的属性信息，然后通过父组件props传递给封装的Swiper组件123456789101112131415161718192021222324252627282930props: &#123; swipeid: &#123; type: String, default: \"\" &#125;, effect: &#123; type: String, default: \"slide\" &#125;, loop: &#123; type: Boolean, default: false &#125;, direction: &#123; type: String, default: \"horizontal\" &#125;, pagination: &#123; type: Boolean, default: true &#125;, paginationType: &#123; type: String, default: \"bullets\" &#125;, autoPlay: &#123; type: Number, default: 3000 &#125; &#125;下面解释属性含义swipeid** 轮播容器class属性的类名effect** 图片的 切换效果，默认为&quot;slide&quot;，还可设置为&quot;fade&quot;, “cube”, “coverflow”,“flip”loop** 设置为true 则开启loop模式。loop模式：会在原本图片前后复制若干个图片并在合适的时候切换，让Swiper看起来是循环的direction** 图片的滑动方向，可设置水平(horizontal)或垂直(vertical)pagination** 使用分页导航paginationType** 分页器样式类型，可设置为&quot;bullets&quot;, “fraction”, “progressbar”, “custom”autoPlay** 设置为true启动自动切换，并使用默认的切换设置全都是swiper.js定义的属性初始化Swiper时，需要传入两个参数，轮播容器的类名和代表图片轮播组件详细功能的对象12345678910111213141516171819202122232425var that = this; this.dom = new Swiper(\".\" + that.swipeid, &#123; //循环 loop: that.loop, //分页器 pagination: &#123; el: \".swiper-pagination\", bulletClass : 'swiper-pagination-bullet', &#125;, //分页类型 paginationType: that.paginationType, //自动播放 autoPlay: that.autoPlay, //方向 direction: that.direction, //特效 effect: that.effect, //用户操作swiper之后，不禁止autoplay disableOnInteraction: false, //修改swiper自己或子元素时，自动初始化swiper observer: true, //修改swiper的父元素时，自动初始化swiper observeParents: true &#125;); &#125; 四、示例代码1.HTML代码123456&lt;m-swipe swipeid=\"swipe\" ref=\"swiper\" :autoPlay=\"3000\" effect=\"slide\"&gt; &lt;div v-for=\"top in tops\" :key=\"top.id\" class=\"swiper-slide\" slot=\"swiper-con\" &gt; &lt;img :src=\"top.image\"&gt; &lt;h3&gt;&#123;&#123;top.title&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/m-swipe&gt;2.css代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.swiper-container &#123; width: 100%; &#125; .swiper-slide &#123; height: 8rem; overflow: hidden; position: relative; &#125;.swiper-slide &#123; div &#123; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.4; position: absolute; background-color: @blue; &#125; img &#123; top: 50%; position: relative; transform: translate(0, -50%); &#125; h3 &#123; width: 70%; color: #fff; margin: 0; font-size: 0.5rem; line-height: 1rem; right: 5%; bottom: 2.6rem; text-align: right; position: absolute; text-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5); &amp;:before &#123; content: \"\"; width: 3rem; bottom: -0.6rem; right: 0; display: block; position: absolute; border: 2px solid @yellow; &#125; &#125;&#125;.swiper-pagination-bullet-active &#123; background: #fff;&#125;.swiper-container-horizontal &gt; .swiper-pagination-bullets &#123; bottom: 1rem; width: 95%; text-align: right; &#125; 总结1.引入swiper-animation 代码时候会各种报错，原因是压缩的代码断行出现问题，使用未压缩的版本2.vue-awesome-swiper 初始化后height 100%，总会出现各种问题，添加自定义动画后滑动快慢都会出现问题3.vue-Swiper 只有简单的的轮播功能，没有添加动画库 本文参考https://juejin.im/post/5a7957ed6fb9a0633d71bb94","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://charlycheng.xyz/categories/前端开发/"}],"tags":[{"name":"swiper","slug":"swiper","permalink":"http://charlycheng.xyz/tags/swiper/"}]},{"title":"GoLang入门","slug":"Go语言入门（-）","date":"2018-03-28T05:57:17.000Z","updated":"2018-04-21T12:41:03.000Z","comments":true,"path":"2018/03/28/Go语言入门（-）/","link":"","permalink":"http://charlycheng.xyz/2018/03/28/Go语言入门（-）/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\"More info: Writing Run server1$ hexo serverMore info: Server Generate static files1$ hexo generateMore info: Generating Deploy to remote sites1$ hexo deployMore info: Deployment","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://charlycheng.xyz/categories/后端开发/"}],"tags":[]}]}